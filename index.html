<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Satellite Look Angle Calculator</title>
  <link rel="icon" href="https://raw.githubusercontent.com/pgarciafer/pics2PDF/main/logo1.png" type="image/png">
  
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  
  <style>
    /* 1. Reset & Root Variables */
    *, *::before, *::after {
      box-sizing: border-box;
    }
    :root {
      --primary-color: #005A9C; /* Corporate Blue */
      --primary-hover: #004a80;
      --secondary-color: #6c757d;
      --secondary-hover: #5a6268;
      --danger-color: #dc3545;
      --danger-hover: #c82333;
      --light-bg: #f8f9fa;
      --border-color: #dee2e6;
      --text-color: #212529;
      --text-muted: #6c757d;
      --card-shadow: 0 4px 12px rgba(0,0,0,0.08);
      --input-focus-shadow: 0 0 0 0.25rem rgba(0, 90, 156, 0.25);
      --input-invalid-shadow: 0 0 0 0.25rem rgba(220, 53, 69, 0.25);
      font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      color: var(--text-color);
    }

    /* 2. Body & Layout */
    body {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      margin: 0;
      padding: 20px;
      background-color: var(--light-bg);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    body::before {
      content: '';
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 50vw;
      height: 50vh;
      max-width: 400px;
      max-height: 400px;
      background-image: url('https://raw.githubusercontent.com/pgarciafer/pics2PDF/main/logo1.png');
      background-repeat: no-repeat;
      background-position: center;
      background-size: contain;
      opacity: 0.04;
      z-index: -1;
    }
    .main-container {
      display: flex;
      flex-direction: column;
      width: 100%;
      gap: 20px;
      position: relative;
      z-index: 1;
      max-width: 1800px;
    }
    .card {
      background: #ffffff;
      border-radius: 8px;
      box-shadow: var(--card-shadow);
      border: 1px solid var(--border-color);
      padding: 24px;
      width: 100%;
    }
    .app-header {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 10px;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 16px;
      margin-bottom: 24px;
    }
    .app-logo {
      height: 60px;
      width: auto;
    }

    /* 3. Typography */
    h1 {
      font-size: 20px;
      margin: 0;
      color: var(--primary-color);
      text-align: center;
      font-weight: 600;
      letter-spacing: -0.5px;
      border-bottom: none;
      padding-bottom: 0;
    }
    h4 {
      color: var(--text-color);
      font-weight: 600;
      margin-top: 0;
      margin-bottom: 15px;
    }
    label { font-weight: 500; }

    /* 4. Forms */
    button {
      padding: 10px 16px; border-radius: 6px; border: 1px solid transparent;
      background-color: var(--primary-color); color: white;
      cursor: pointer; font-weight: 500; font-size: 14px;
      transition: background-color 0.15s ease-in-out, transform 0.1s ease;
      -webkit-appearance: none;
    }
    button:hover { background-color: var(--primary-hover); }
    button:active { transform: scale(0.98); }
    button:disabled { background-color: #ccc; cursor: not-allowed; opacity: 0.7; }

    button.secondary { background-color: var(--secondary-color); }
    button.secondary:hover { background-color: var(--secondary-hover); }
    button.small { padding: 6px 12px; font-size: 13px; }

    input[type="text"], input[type="number"], input[type="file"], select {
      width: 100%;
      min-width: 0;
      border: 1px solid var(--border-color);
      background: #fff;
      font-size: 15px;
      color: var(--text-color);
      outline: none;
      padding: 8px;
      border-radius: 6px;
      transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
    }
    input[type="text"]:focus, input[type="number"]:focus, select:focus {
      border-color: var(--primary-color);
      box-shadow: var(--input-focus-shadow);
    }
    input.invalid, select.invalid {
      border-color: var(--danger-color) !important;
      box-shadow: var(--input-invalid-shadow) !important;
    }
    input[type=number]::-webkit-inner-spin-button, 
    input[type=number]::-webkit-outer-spin-button { 
      -webkit-appearance: none; 
      margin: 0; 
    }
    input[type=number] {
      -moz-appearance: textfield;
    }
    input[type="file"] {
      padding: 5px;
    }
    .coord-item {
      display: grid;
      grid-template-columns: minmax(60px,100px) 1fr auto;
      align-items: center; gap: 8px; margin-bottom: 8px;
    }
    .coord-item label {
      color: var(--text-muted); font-weight: 500; font-size: 14px;
    }
    .coord-item input, .coord-item select { text-align: center; }
    .coord-item select { text-align-last: center; }

    .button-row {
      display: flex; flex-direction: column; gap: 8px;
      justify-content: center; margin-bottom: 16px;
    }

    /* 5. Components */
    table {
      width: 100%; border-collapse: collapse; margin-top: 12px; font-size: 14px;
    }
    th, td {
      text-align: center; padding: 10px 4px;
      border-bottom: 1px solid var(--border-color);
    }
    th {
      color: var(--text-muted); font-weight: 600;
      background-color: var(--light-bg);
      border-top: 1px solid var(--border-color);
    }
    td input {
      width: 90px; text-align: center; padding: 6px;
    }
    #zonesTable td button {
      width: 28px; height: 28px; font-size: 14px;
      border: none; background-color: var(--danger-color); color: #fff;
      border-radius: 4px; cursor: pointer; padding: 0;
      float: right; transition: background-color 0.2s ease;
    }
    #zonesTable td button:hover { background: var(--danger-hover); }

    #satRangesList {
      margin-top: 12px; font-size: 14px; line-height: 1.6;
      display: grid; grid-template-columns: 1fr; gap: 8px 16px;
    }
    #satRangesList.two-col { grid-template-columns: 1fr 1fr; }

    canvas {
      background: white; border-radius: 8px;
      border: 1px solid var(--border-color);
      width: 100%; max-width: 400px; height: auto;
    }
    
    #elGraph {
        height: 150px; /* Fixed height for the elevation graph */
    }

    .diagram { display: flex; flex-direction: column; align-items: center; margin-bottom: 12px; }
    .diagram-info div { margin-bottom: 4px; }
    .main-column { display: flex; flex-direction: column; gap: 5px; width: 100%; }
    .blocking-section { width: 100%; display: flex; flex-direction: column; align-items: center; gap: 8px; }

    #mapid {
      height: 400px; width: 100%; border-radius: 8px; margin-top: 20px;
      border: 1px solid var(--border-color);
    }

    .legend {
      line-height: 18px; color: var(--text-muted);
      background-color: white; padding: 10px;
      box-shadow: 0 0 15px rgba(0,0,0,0.2);
      border-radius: 5px; border: 1px solid var(--border-color);
      max-height: 250px; overflow-y: auto; margin-bottom: 10px;
    }
    .legend h4 { margin-bottom: 10px; font-size: 16px; }
    .legend i { width: 18px; height: 18px; float: left; margin-right: 8px; border-radius: 3px; }
    .legend-item { cursor: pointer; display: flex; align-items: center; gap: 8px; margin-bottom: 5px; }
    .legend-item.hidden { opacity: 0.4; }
    .legend-button {
      display: block; width: 100%;
      padding: 8px; margin-bottom: 10px;
      cursor: pointer; text-align: center;
      background-color: var(--light-bg);
      border: 1px solid var(--border-color);
      border-radius: 5px;
      color: var(--text-color);
      font-weight: 500;
    }
    .legend-button:hover { background-color: #e2e6ea; }

    #beamDetails {
      margin-top: 20px; padding: 15px;
      border: 1px solid var(--border-color); border-radius: 8px;
      background-color: var(--light-bg);
      font-family: monospace; white-space: pre-wrap;
      font-size: 13px; line-height: 1.6;
    }

    .sat-lists-container {
      display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px; margin-top: 20px; text-align: left;
    }
    .sat-list {
      border: 1px solid var(--border-color);
      border-radius: 8px; padding: 15px;
      height: 300px; overflow-y: auto; background: #fff;
    }
    .sat-list h4 { margin-bottom: 10px; font-size: 16px; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
    .sat-list-item {
      padding: 8px; border-bottom: 1px solid var(--light-bg);
      cursor: pointer; transition: background-color 0.15s ease;
      border-radius: 4px;
      font-size: 14px;
    }
    .sat-list-item:hover { background-color: var(--light-bg); }
    .sat-list-item.selected {
      background-color: #e7f1ff; /* Light blue for selection */
      font-weight: 600;
      color: var(--primary-color);
    }
    #zonesTable td:first-child { display: flex; align-items: center; justify-content: center; }
    #zonesTable td:first-child input { flex-grow: 1; }
    #zonesTable td:first-child span { margin-right: 5px; }

    /* 6. Layout & Responsiveness */
    .narrow-table { max-width: 300px; margin: 0 auto; }
    .narrow-table input { width: 65px; }
    
    .desktop-top-row {
      display: flex;
      flex-direction: column;
      gap: 20px; /* More vertical gap for mobile */
    }
    .results-section {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
    }
    .desktop-diagrams-row {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      width: 100%;
    }
    .legend-container-mobile {
      display: none;
    }

    @media (max-width: 1023px) {
      #mapid {
        height: 350px;
      }
      .legend-container-mobile {
        display: block;
        padding: 0 15px 15px;
      }
      .legend-container-mobile .legend {
        margin-top: 15px;
        box-shadow: none;
      }
    }

    @media (min-width: 600px) {
      .app-header {
        flex-direction: row;
        gap: 15px;
      }
      h1 {
        font-size: 24px;
        text-align: left;
      }
      .button-row { flex-direction: row; gap: 10px; }
    }

    @media (min-width: 1024px) {
      .main-container { flex-direction: row; align-items: flex-start; }
      .card:first-child { flex-basis: 600px; flex-shrink: 0; }
      .card:last-child { flex: 1; }
      #mapid { height: 600px; margin-top: 0; }

      .desktop-top-row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 24px;
        align-items: start;
      }
      .desktop-diagrams-row {
        flex-direction: row;
        align-items: center;
        gap: 24px;
      }
      .results-section .diagram-info {
        text-align: center;
      }
      #vessel-diagram-container {
        flex: 0 0 260px; /* Adjusted width for vessel diagram */
      }
      .desktop-diagrams-row .diagram:last-child {
        flex: 1; /* Make EL graph container fill remaining space */
        min-width: 0;
      }
      .desktop-diagrams-row .diagram:last-child #elGraph {
        max-width: 100%; /* Override default canvas max-width */
      }
    }
    
    /* 7. PDF Export Styles */
    body.pdf-export-mode {
      /* Prevent scrollbars from appearing during export resizing */
      overflow-y: hidden !important;
    }
    body.pdf-export-mode .main-container {
      /* Set a fixed large width and apply desktop flex layout */
      width: 1800px;
      flex-direction: row;
      align-items: flex-start;
    }
    body.pdf-export-mode .card:first-child {
      flex-basis: 600px;
      flex-shrink: 0;
      width: 600px;
    }
    body.pdf-export-mode .card:last-child {
      flex: 1;
    }
    body.pdf-export-mode .results-section .diagram-info {
      text-align: center;
    }
    body.pdf-export-mode .desktop-top-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
      align-items: start;
    }
    body.pdf-export-mode .desktop-diagrams-row {
      flex-direction: row;
      align-items: center;
      gap: 24px;
    }
    body.pdf-export-mode #vessel-diagram-container {
      flex: 0 0 260px;
    }
    body.pdf-export-mode .desktop-diagrams-row .diagram:last-child {
      flex: 1;
      min-width: 0;
    }
    body.pdf-export-mode .desktop-diagrams-row .diagram:last-child #elGraph {
      max-width: 100%;
    }

    /* 8. Print Styles */
    @media print {
      body { background: none; padding: 0; }
      body::before { display: none; }
      .button-row, button, #file-input, label[for="file-input"], .legend, #legend-container-mobile {
        display: none !important;
      }
      body, .card {
        margin: 0; padding: 0;
        box-shadow: none; border: none;
      }
      .main-container {
        flex-direction: column; width: 100%; padding: 10mm; gap: 0;
      }
      .card:last-child { page-break-before: always; }
      h1, h4 { margin-top: 10mm; }
    }
  </style>

</head>
<body>
<div class="main-container">
  <div class="card" role="region" aria-label="Device coordinates">
    <div class="app-header">
      <img src="https://raw.githubusercontent.com/pgarciafer/MTNsatcalc/main/logo.png" alt="MTN Logo" class="app-logo">
      <h1>Satellite Look Angle Calculator</h1>
    </div>

    <div class="main-column">
        <div class="button-row">
          <button id="refreshBtn" data-html2canvas-ignore="true">Get Location</button>
          <button id="copyBtn" class="secondary" disabled data-html2canvas-ignore="true">Copy</button>
          <button id="pdfBtn" class="secondary" data-html2canvas-ignore="true">PDF</button>
        </div>
        
        <div style="margin-bottom: 15px;" data-html2canvas-ignore="true">
          <label for="file-input">Load Satellite Constellation File:</label>
          <input type="file" id="file-input" accept=".json" data-html2canvas-ignore="true">
        </div>

        <div class="desktop-top-row">
          <div class="coords" aria-live="polite">
            <div class="coord-item">
              <label for="lat">Latitude</label>
              <input id="lat" type="text" inputmode="decimal" value="38.88" />
              <select id="latDir"><option value="N" selected>N</option><option value="S">S</option></select>
            </div>
            <div class="coord-item">
              <label for="lon">Longitude</label>
              <input id="lon" type="text" inputmode="decimal" value="1.40" />
              <select id="lonDir"><option value="E" selected>E</option><option value="W">W</option></select>
            </div>
            <div class="coord-item">
              <label for="satLon">Satellite Longitude</label>
              <input id="satLon" type="text" inputmode="decimal" value="18.00" />
              <select id="satLonDir"><option value="E">E</option><option value="W" selected>W</option></select>
            </div>
            <div class="coord-item">
              <label for="heading">Heading</label>
              <input id="heading" type="text" inputmode="decimal" value="0.00" />
              <div style="width:48px;"></div>
            </div>
          </div>

          <div id="blockingZonesSection" class="blocking-section">
            <table id="zonesTable" style="display:none;">
              <thead>
                <tr>
                  <th>AZ Start</th>
                  <th>AZ Stop</th>
                  <th>EL Blockage</th>
                  <th></th>
                </tr>
              </thead>
              <tbody id="zonesBody"></tbody>
            </table>
            <button type="button" id="addBlockBtn" data-html2canvas-ignore="true">Add Blockage Zone</button>
          </div>
        </div>

    <div class="coord-item" style="display:none;">
            <label for="satDropdown">Visible Satellites</label>
            <select id="satDropdown"></select>
            <div style="width:48px;"></div>
        </div>
        
        <div class="results-section">
            <div class="diagram-info">
                <div id="azVal" style="font-weight:bold; text-align: center">AZ=</div>
                <div id="elVal" style="font-weight:bold; text-align: center">EL=</div>
                <div id="relVal" style="font-weight:bold; text-align: center">REL=</div>
                <div id="relBlockMsg" style="font-weight:bold; margin-top:4px;"></div>
                <div id="visibleRange" style="font-weight:bold; text-align: center; margin-top: 8px;"></div>
            </div>
            
            <div class="desktop-diagrams-row">
                <div id="vessel-diagram-container" class="diagram">
                    <canvas id="vesselCanvas" width="300" height="300"></canvas>
                </div>
                 <div class="diagram">
                    <canvas id="elGraph" width="300" height="150"></canvas>
                </div>
            </div>
            
            <table id="trimTable" class="narrow-table">
                <thead>
                    <tr>
                        <th></th>
                        <th>RX Green</th>
                        <th>Current Trim</th>
                        <th>New Trim</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>AZ</td>
                        <td><input type="number" id="azGreen"></td>
                        <td><input type="number" id="azCurrent" value="0"></td>
                        <td><input type="text" id="azNew" readonly></td>
                    </tr>
                    <tr>
                        <td>EL</td>
                        <td><input type="number" id="elGreen"></td>
                        <td><input type="number" id="elCurrent" value="0"></td>
                        <td><input type="text" id="elNew" readonly></td>
                    </tr>
                </tbody>
            </table>
            <div id="satRangesList"></div>
        </div>

    </div>
  </div>

  <div class="card" style="display:flex; flex-direction:column;">
    <div id="mapid"></div>
    <div id="legend-container-mobile"></div>

    <div class="sat-lists-container">
        <div id="visibleSatellites" class="sat-list">
            <h4>Visible and Unblocked Satellites</h4>
        </div>
        <div id="blockedSatellites" class="sat-list">
            <h4>Blocked Satellites</h4>
        </div>
        <div id="satelliteDetails" class="sat-list">
            <h4>Satellite Details</h4>
            <div id="beamDetails"></div>
        </div>
    </div>
  </div>
    
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <script>
    const latEl=document.getElementById('lat'), lonEl=document.getElementById('lon');
    const latDir=document.getElementById('latDir'), lonDir=document.getElementById('lonDir');
    const satLonEl=document.getElementById('satLon'), satLonDir=document.getElementById('satLonDir');
    const headingEl=document.getElementById('heading');
    const refreshBtn=document.getElementById('refreshBtn'), copyBtn=document.getElementById('copyBtn'), pdfBtn=document.getElementById('pdfBtn');
    const azVal=document.getElementById('azVal'), elVal=document.getElementById('elVal'), relVal=document.getElementById('relVal');
    const zonesTable=document.getElementById("zonesTable");
    const zonesBody=document.getElementById("zonesBody");
    const addBlockBtn=document.getElementById("addBlockBtn");
    const satRangesList=document.getElementById("satRangesList");
    const elGraphCanvas = document.getElementById("elGraph");
    let elGraphSatPoints = [];
    const MIN_ELEVATION = 5;
    const zoneColors = [
      "rgba(255, 0, 0, 0.5)",
      "rgba(0, 128, 255, 0.5)",
      "rgba(0, 200, 0, 0.5)",
      "rgba(255, 165, 0, 0.5)",
      "rgba(128, 0, 128, 0.5)",
      "rgba(255, 20, 147, 0.5)"
    ];
    const beamDetailsEl = document.getElementById('beamDetails');
    const visibleSatellitesList = document.getElementById('visibleSatellites');
    const blockedSatellitesList = document.getElementById('blockedSatellites');
    
    // New Trim table elements
    const azGreenEl = document.getElementById('azGreen');
    const azCurrentEl = document.getElementById('azCurrent');
    const azNewEl = document.getElementById('azNew');
    const elGreenEl = document.getElementById('elGreen');
    const elCurrentEl = document.getElementById('elCurrent');
    const elNewEl = document.getElementById('elNew');
    
    function formatNumber(num) {
      return (Math.round(num * 100) / 100).toString().replace(/\.00$/, "");
    }
    function resizeCanvas(canvas) {
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * 2;
      canvas.height = rect.height * 2;
    }

function drawElGraph(lat, lon) {
  const canvas = elGraphCanvas;
  resizeCanvas(canvas);
  const ctx = canvas.getContext("2d");

  const margin = 40;
  const width = canvas.width - 2 * margin;
  const height = canvas.height - 2 * margin;

  const step = 0.5;
  let visibleLons = [];
  for (let lonSat = -180; lonSat <= 180; lonSat += step) {
    const { el: testEl } = calcAzEl(lat, lon, lonSat);
    if (testEl > MIN_ELEVATION) visibleLons.push(lonSat);
  }
  let minVisible = -180, maxVisible = 180;
  if (visibleLons.length > 0) {
    minVisible = Math.min(...visibleLons) - 5;
    maxVisible = Math.max(...visibleLons) + 5;
    if (minVisible < -180) minVisible = -180;
    if (maxVisible > 180) maxVisible = 180;
  }

  function toX(lonSat) {
    return margin + (lonSat - minVisible) * (width / (maxVisible - minVisible));
  }
  function toY(el) {
    const clampedEl = Math.max(0, el);
    return canvas.height - margin - (clampedEl / 90) * height;
  }
  function normalizeLon(lon) {
    return ((lon + 180) % 360 + 360) % 360 - 180;
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  function shadeBand(elMin, elMax, color) {
    const top = toY(elMax);
    const bottom = toY(elMin);
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.2;
    ctx.fillRect(toX(minVisible), top, toX(maxVisible) - toX(minVisible), bottom - top);
    ctx.globalAlpha = 1.0;
  }
  shadeBand(0, MIN_ELEVATION, "red");
  shadeBand(MIN_ELEVATION, 15, "yellow");
  shadeBand(15, 65, "green");
  shadeBand(65, 80, "yellow");
  shadeBand(80, 90, "red");

const { heading } = getLatLon();
const rows = Array.from(zonesBody.querySelectorAll('tr'));
if (rows.length > 0) {
  ctx.globalAlpha = 0.25;
  rows.forEach((row, idx) => {
    const startAZ = parseFloat(row.cells[0].querySelector("input").value);
    const stopAZ  = parseFloat(row.cells[1].querySelector("input").value);
    const elBlock  = parseFloat(row.cells[2].querySelector("input").value);
    if (isNaN(startAZ) || isNaN(stopAZ) || isNaN(elBlock)) return;

    const ranges = computeSatRangesForZone(startAZ, stopAZ, lat, lon, heading, 0.5);
    ctx.fillStyle = zoneColors[idx % zoneColors.length];

    ranges.forEach(([startLon, endLon]) => {
      const top = toY(elBlock);
      const bottom = toY(0);
      ctx.fillRect(toX(startLon), top, toX(endLon) - toX(startLon), bottom - top);
    });
  });
  ctx.globalAlpha = 1.0;
}

  ctx.strokeStyle = "black";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(toX(minVisible), toY(0));
  ctx.lineTo(toX(maxVisible), toY(0));
  ctx.moveTo(toX(minVisible), toY(0));
  ctx.lineTo(toX(minVisible), toY(90));
  ctx.stroke();

  ctx.fillStyle = "black";
  ctx.font = "20px sans-serif";
  ctx.textAlign = "center";

  const tickStep = 30;
  for (let lon = Math.ceil(minVisible / tickStep) * tickStep; lon <= maxVisible; lon += tickStep) {
    const x = toX(lon);
    ctx.beginPath();
    ctx.moveTo(x, toY(0));
    ctx.lineTo(x, toY(0) + 5);
    ctx.stroke();
    let label;
    if (lon < 0) {
      label = `${Math.abs(lon)}°W`;
    } else if (lon > 0) {
      label = `${lon}°E`;
    } else {
      label = `0°`;
    }
    ctx.fillText(label, x, toY(0) + 15);
  }

  ctx.fillStyle = "black";
  ctx.font = "18px sans-serif";
  
  ctx.textAlign = "left";
  ctx.fillText(
    formatLonEW(Math.round(minVisible)),
    toX(minVisible),
    toY(0) + 30
  );

  ctx.textAlign = "right";
  ctx.fillText(
    formatLonEW(Math.round(maxVisible)),
    toX(maxVisible),
    toY(0) + 30
  );

  ctx.textAlign = "right";
  for (let el = 0; el <= 90; el += 15) {
    const y = toY(el);
    ctx.beginPath();
    ctx.moveTo(toX(minVisible), y);
    ctx.lineTo(toX(minVisible) - 5, y);
    ctx.stroke();
    ctx.fillText(el.toString(), toX(minVisible) - 8, y + 3);
  }

  const satLons = [];
  const elevations = [];
  const satLonStep = 1;
  for (let lonSat = minVisible; lonSat <= maxVisible; lonSat += satLonStep) {
    const { el } = calcAzEl(lat, lon, lonSat);
    satLons.push(lonSat);
    elevations.push(el);
  }
  ctx.strokeStyle = "blue";
  ctx.lineWidth = 2;
  ctx.beginPath();
  satLons.forEach((lonSat, i) => {
    const x = toX(lonSat);
    const y = toY(elevations[i]);
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  });
  ctx.stroke();

  const { lat: currentLat, lon: currentLon, heading: currentHeading } = getLatLon();
  const userPoint = { lat: currentLat, lng: currentLon };
  const uniqueVisibleSats = new Map();

  Object.values(allBeamsData).forEach(beamData => {
    if (checkFootprintVisibility(beamData, userPoint)) {
        if (!uniqueVisibleSats.has(beamData.longitude)) {
            uniqueVisibleSats.set(beamData.longitude, beamData);
        }
    }
  });

  elGraphSatPoints = []; // Clear previous points
  uniqueVisibleSats.forEach((beamData, satLon) => {
      const { az, el } = calcAzEl(currentLat, currentLon, satLon);
      if (el >= MIN_ELEVATION) {
          const rel = ((az - currentHeading) + 360) % 360;
          const isBlocked = checkBlockingZones(rel, el);
          
          const x = toX(satLon);
          const y = toY(el);
          
          elGraphSatPoints.push({ lon: satLon, x: x, y: y });

          ctx.beginPath();
          ctx.arc(x, y, 8, 0, 2 * Math.PI); // 8px radius circle
          ctx.fillStyle = isBlocked ? 'orange' : '#00C853'; // Orange for blocked, bright green for visible
          ctx.fill();
          ctx.strokeStyle = 'rgba(0,0,0,0.6)';
          ctx.lineWidth = 1.5;
          ctx.stroke();
      }
  });

  ctx.strokeStyle = "red";
  ctx.setLineDash([5, 3]);
  ctx.beginPath();
  ctx.moveTo(toX(minVisible), toY(MIN_ELEVATION));
  ctx.lineTo(toX(maxVisible), toY(MIN_ELEVATION));
  ctx.stroke();
  ctx.setLineDash([]);

  let { satLon } = getLatLon();
  satLon = normalizeLon(satLon);
  if (satLon >= minVisible && satLon <= maxVisible) {
    ctx.strokeStyle = "purple";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(toX(satLon), toY(0));
    ctx.lineTo(toX(satLon), toY(90));
    ctx.stroke();

    ctx.fillStyle = "purple";
    ctx.font = "22px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(formatLonEW(satLon), toX(satLon), canvas.height - margin + 28);

    const { el: satEl } = calcAzEl(lat, lon, satLon);
    ctx.beginPath();
    ctx.arc(toX(satLon), toY(satEl), 4, 0, 2 * Math.PI);
    ctx.fill();
    ctx.fillText(`${satEl.toFixed(1)}°`, toX(satLon), toY(satEl) - 8);
  }
}

    function formatLonEW(lon) {
      if (lon > 0) return formatNumber(lon) + "°E";
      if (lon < 0) return formatNumber(Math.abs(lon)) + "°W";
      return "0°";
    }
function checkBlockingZones(rel, el) {
  const rows = zonesBody.querySelectorAll("tr");
  const matches = [];
  let zoneIndex = 0;

  for (const row of rows) {
    zoneIndex++;
    const start = parseFloat(row.cells[0].querySelector("input").value);
    const stop  = parseFloat(row.cells[1].querySelector("input").value);
    const elBlock  = parseFloat(row.cells[2].querySelector("input").value);

    if (isNaN(start) || isNaN(stop) || isNaN(elBlock)) continue;

    let startAZ = (start + 360) % 360;
    let stopAZ = (stop + 360) % 360;
    let inZone = false;

    if (startAZ <= stopAZ) {
      inZone = (rel >= startAZ && rel <= stopAZ);
    } else {
      inZone = (rel >= startAZ || rel <= stopAZ);
    }

    if (inZone && el < elBlock) {
      matches.push({ index: zoneIndex, start, stop, elBlock });
    }
  }
  return matches.length ? matches : null;
}

function createZoneRow(start = 0.00, stop = 0.00, elBlock = 10) {
    if (zonesTable.classList.contains("narrow-table") === false) {
        zonesTable.classList.add("narrow-table");
    }
  const tr = document.createElement("tr");
  const rowIndex = zonesBody.children.length;
  const color = zoneColors[rowIndex % zoneColors.length].replace("0.5", "1.0");

  tr.innerHTML = `
    <td><span style="color:${color};">&#9679;</span><input type="number" step="0.01" value="${formatNumber(start)}"></td>
    <td><input type="number" step="0.01" value="${formatNumber(stop)}"></td>
    <td><input type="number" step="0.01" value="${formatNumber(elBlock)}"></td>
    <td><button class="small" data-html2canvas-ignore="true">X</button></td>
  `;

  const inputs = tr.querySelectorAll("input");
  inputs.forEach(inp => {
    inp.addEventListener("input", updateAll);
    inp.addEventListener("blur", () => {
      let val = (inp.value || "").trim().replace(",", ".");
      let num = parseFloat(val);
      if (isNaN(num)) num = 0;
      if (inp === inputs[2]) {
        if (num < 0) num = 0;
        if (num > 90) num = 90;
      } else {
        if (num < 0) num = 0;
        if (num > 360) num = 360;
      }
      inp.value = formatNumber(num);
      updateAll();
    });
    inp.addEventListener("focus", e => setTimeout(() => e.target.select(), 0));
  });

  tr.querySelector("button").addEventListener("click", () => {
    tr.remove();
    if (zonesBody.children.length === 0) zonesTable.style.display = "none";
    setupKeyboardNavigation();
    updateAll();
  });

  zonesBody.appendChild(tr);
  zonesTable.style.display = "table";
  setupKeyboardNavigation();
  updateAll();
}
    addBlockBtn.addEventListener("click", () => createZoneRow());
    
    // --- MODIFIED FUNCTION: normalizeInput for 0-180 E/W enforcement ---
    function normalizeInput(input, max) {
        let val = (input.value || "").trim().replace(",", ".");
        if (val === "") return;
        let num = parseFloat(val);
        if (isNaN(num)) return;

        if (input.type === "number") {
             // For number types, just format
             input.value = formatNumber(num);
        } else if (input.id === "heading") {
            if (num < 0) num = 0;
            if (num > 360) num = 360;
            input.value = formatNumber(num);
        } else {
            // Longitude/SatLon normalization (0 to 180 E/W)
            let dirSelect = input.id === "lon" ? lonDir : satLonDir;
            let dir = dirSelect.value;
            let mag = Math.abs(num);
            mag = mag % 360;

            if (mag > 180) {
                mag = 360 - mag;
                dirSelect.value = (dir === "E") ? "W" : "E";
            }
            
            input.value = formatNumber(mag);
        }
    }
    // --- END MODIFIED FUNCTION ---

    function getLatLon() {
      const latVal = parseFloat((latEl.value || "").trim().replace(",", ".")) || 0;
      const lonVal = parseFloat((lonEl.value || "").trim().replace(",", ".")) || 0;
      const satLonVal = parseFloat((satLonEl.value || "").trim().replace(",", ".")) || 0;
      const headingVal = parseFloat((headingEl.value || "").trim().replace(",", ".")) || 0;
      const lat = latDir.value === "N" ? latVal : -latVal;
      const lon = lonDir.value === "E" ? lonVal : -lonVal;
      const satLon = satLonDir.value === "E" ? satLonVal : -satLonVal;
      return { lat, lon, satLon, heading: headingVal };
    }
    function calcAzEl(lat, lon, satLon) {
        const toRad = Math.PI / 180;
        const R = 6378.137; // Earth radius in km
        const H = 35786.0; // Geostationary altitude in km

        const latR = lat * toRad;
        const lonR = lon * toRad;
        
        const g = lonR - (satLon * toRad); // Difference in longitude

        const L = latR;

        // Intermediate calculation
        const r_c = Math.sqrt(Math.pow(R + H, 2) - Math.pow(R, 2) * Math.pow(Math.cos(L), 2) * (1 - Math.pow(Math.cos(g), 2)));
        const r_s = R * Math.cos(L) * Math.cos(g);
        const l_s = (r_c - r_s) / R;

        // Elevation calculation
        const el = Math.atan((Math.cos(L) * Math.cos(g) - R / (R + H)) / Math.sqrt(1 - Math.pow(Math.cos(L), 2) * Math.pow(Math.cos(g), 2))) / toRad;

        // Azimuth calculation
        let az = Math.atan(Math.tan(Math.abs(g)) / Math.sin(L)) / toRad;

        if (lat < 0) { // Southern hemisphere
            if (g > 0) az = 180 - az;
        } else { // Northern hemisphere
            if (g < 0) az = 180 - az;
        }
        if (g > 0 && lat > 0) az = 180 + az;
        if (g < 0 && lat < 0) az = 360 - az;
        if (az > 360) az -= 360;
        
        return { az, el };
    }
    const vesselImg = new Image();
  vesselImg.crossOrigin = "anonymous";
    vesselImg.src = "https://pgarciafer.github.io/satcalc/IMG_0585.PNG";
    const vesselCanvas = document.getElementById("vesselCanvas");
    const vesselCtx = vesselCanvas.getContext("2d");
function drawVesselWithREL(rel, lat, lon, heading) {
  vesselCtx.clearRect(0, 0, vesselCanvas.width, vesselCanvas.height);

  const scaleFactor = 0.75;
  const scale = Math.min(vesselCanvas.width / vesselImg.width, vesselCanvas.height / vesselImg.height) * scaleFactor;
  const imgW = vesselImg.width * scale;
  const imgH = vesselImg.height * scale;
  const imgX = (vesselCanvas.width - imgW) / 2;
  const imgY = (vesselCanvas.height - imgH) / 2;

  vesselCtx.drawImage(vesselImg, imgX, imgY, imgW, imgH);

  const centerX = vesselCanvas.width / 2;
  const centerY = vesselCanvas.height / 2;
  const radius = Math.min(imgW, imgH) / 2;

  const rows = Array.from(zonesBody.querySelectorAll('tr'));
  rows.forEach((row, idx) => {
    const start = parseFloat(row.cells[0].querySelector("input").value);
    const stop = parseFloat(row.cells[1].querySelector("input").value);
    if (isNaN(start) || isNaN(stop)) return;

    const startRad = (start - 90) * Math.PI / 180;
    const stopRad  = (stop - 90) * Math.PI / 180;

    vesselCtx.beginPath();
    vesselCtx.moveTo(centerX, centerY);
    vesselCtx.arc(centerX, centerY, radius, startRad, stopRad, false);
    vesselCtx.closePath();

    vesselCtx.fillStyle = zoneColors[idx % zoneColors.length];
    vesselCtx.fill();
  });

  const angleRad = (rel - 90) * Math.PI / 180;
  const endX = centerX + radius * Math.cos(angleRad);
  const endY = centerY + radius * Math.sin(angleRad);

  vesselCtx.beginPath();
  vesselCtx.moveTo(centerX, centerY);
  vesselCtx.lineTo(endX, endY);
  vesselCtx.strokeStyle = "red";
  vesselCtx.lineWidth = 3;
  vesselCtx.stroke();

  // Draw points for all visible satellites
  if (Object.keys(allBeamsData).length > 0 && lat !== undefined && lon !== undefined && heading !== undefined) {
    const userPoint = { lat: lat, lng: lon };
    const uniqueVisibleSats = new Map();

    Object.values(allBeamsData).forEach(beamData => {
        if (checkFootprintVisibility(beamData, userPoint)) {
            if (!uniqueVisibleSats.has(beamData.longitude)) {
                uniqueVisibleSats.set(beamData.longitude, beamData);
            }
        }
    });

    const plotRadius = radius * 0.9;
    const labelOffset = 15;

    uniqueVisibleSats.forEach((beamData, satLon) => {
        const { az, el } = calcAzEl(lat, lon, satLon);
        if (el < MIN_ELEVATION) return;

        const satRel = ((az - heading) + 360) % 360;
        const isBlocked = checkBlockingZones(satRel, el);

        const angleRad = (satRel - 90) * Math.PI / 180;
        const pointX = centerX + plotRadius * Math.cos(angleRad);
        const pointY = centerY + plotRadius * Math.sin(angleRad);
        
        vesselCtx.beginPath();
        vesselCtx.arc(pointX, pointY, 6, 0, 2 * Math.PI);
        vesselCtx.fillStyle = isBlocked ? 'orange' : '#00C853';
        vesselCtx.fill();
        vesselCtx.strokeStyle = 'rgba(0,0,0,0.6)';
        vesselCtx.lineWidth = 1.5;
        vesselCtx.stroke();

        const labelText = formatLonEW(satLon).replace("°", "");
        const labelX = centerX + (plotRadius + labelOffset) * Math.cos(angleRad);
        const labelY = centerY + (plotRadius + labelOffset) * Math.sin(angleRad);

        vesselCtx.fillStyle = '#333';
        vesselCtx.font = '18px sans-serif';
        vesselCtx.textBaseline = 'middle';
        
        if (satRel >= 90 && satRel <= 270) {
            vesselCtx.textAlign = 'end';
        } else {
            vesselCtx.textAlign = 'start';
        }
        if ((satRel >= 80 && satRel <= 100) || (satRel >= 260 && satRel <= 280)) {
            vesselCtx.textAlign = 'center';
        }
        
        vesselCtx.fillText(labelText, labelX, labelY);
    });
  }
}

    function calculateTrim(az, el) {
        const azGreen = parseFloat(azGreenEl.value) || 0;
        const azCurrent = parseFloat(azCurrentEl.value) || 0;
        const elGreen = parseFloat(elGreenEl.value) || 0;
        const elCurrent = parseFloat(elCurrentEl.value) || 0;

        const azNew = Math.round(((az - azGreen) * 10) + azCurrent);
        const elNew = Math.round(((el - elGreen) * 10) + elCurrent);

        azNewEl.value = azNew;
        elNewEl.value = elNew;
    }

    // --- NEW VALIDATION FUNCTIONS ---
    function validateInput(input, min, max, allowNegative = false, isInteger = false) {
        const value = input.value.trim().replace(",", ".");
        let isValid = true;
        
        if (value === '' || (allowNegative && value === '-')) {
            // Empty is ok (user is typing), single minus is ok for negative fields.
        } else {
            const num = parseFloat(value);
            if (isNaN(num)) {
                isValid = false;
            } else {
                if (isInteger && !Number.isInteger(num)) isValid = false;
                if (!allowNegative && num < 0) isValid = false;
                if (min !== undefined && num < min) isValid = false;
                if (max !== undefined && num > max) isValid = false;
            }
        }
        
        if (isValid) {
            input.classList.remove('invalid');
        } else {
            input.classList.add('invalid');
        }
        return isValid;
    }

    function areAllInputsValid() {
        let allValid = true;
        const inputsToValidate = [
            { el: latEl, min: 0, max: 90 },
            { el: lonEl, min: 0, max: 180 },
            { el: satLonEl, min: 0, max: 180 },
            { el: headingEl, min: 0, max: 360 },
            { el: azGreenEl, min: 0, max: 360 },
            { el: elGreenEl, min: 0, max: 90 },
            { el: azCurrentEl, allowNegative: true },
            { el: elCurrentEl, allowNegative: true },
        ];

        inputsToValidate.forEach(item => {
            if (!validateInput(item.el, item.min, item.max, item.allowNegative)) {
                allValid = false;
            }
        });
        
        const zoneRows = zonesBody.querySelectorAll('tr');
        zoneRows.forEach(row => {
            const inputs = row.querySelectorAll('input');
            if (!validateInput(inputs[0], 0, 360)) allValid = false;
            if (!validateInput(inputs[1], 0, 360)) allValid = false;
            if (!validateInput(inputs[2], 0, 90)) allValid = false;
        });
        
        return allValid;
    }
    // --- END VALIDATION FUNCTIONS ---

    function updateAll() {
      if (!areAllInputsValid()) {
          copyBtn.disabled = true;
          pdfBtn.disabled = true;
          return;
      }
      Object.keys(allBeamsData).forEach(id => {
          const beamData = allBeamsData[id];
          if (mymap.hasLayer(beamData.layer)) {
              mymap.removeLayer(beamData.layer);
          }
      });
        
      const { lat, lon, satLon, heading } = getLatLon();
      const { az, el } = calcAzEl(lat, lon, satLon);
      
      azVal.textContent = 'AZ=' + formatNumber(az);
      elVal.textContent = 'EL=' + formatNumber(el);
      const rel = ((az - heading) + 360) % 360;
      relVal.textContent = 'REL=' + formatNumber(rel);
    
const blockZones = checkBlockingZones(rel, el);
const relBlockMsg = document.getElementById("relBlockMsg");

if (blockZones) {
  const zone = blockZones[0];
  relBlockMsg.textContent = `Blockage area #${zone.index} (EL < ${zone.elBlock}°)`;
  relBlockMsg.style.color = zoneColors[(zone.index - 1) % zoneColors.length].replace("0.5", "1");
} else {
  relBlockMsg.textContent = "";
}
    
      if (vesselImg.complete) {
        drawVesselWithREL(rel, lat, lon, heading);
      } else {
        vesselImg.onload = () => drawVesselWithREL(rel, lat, lon, heading);
      }
      if (el < MIN_ELEVATION) {
        elVal.innerHTML = `EL=<span style="color:red;">${formatNumber(el)} (Out of Range)</span>`;
      } else {
        elVal.textContent = 'EL=' + formatNumber(el);
      }
      const step = 0.5;
      let visibleLons = [];
      for (let lonSat = -180; lonSat <= 180; lonSat += step) {
        const { el: testEl } = calcAzEl(lat, lon, lonSat);
        if (testEl > MIN_ELEVATION) visibleLons.push(lonSat);
      }
      if (visibleLons.length > 0) {
        const minLonRaw = Math.min(...visibleLons);
        const maxLonRaw = Math.max(...visibleLons);
        const minLon = formatLonEW(minLonRaw);
        const maxLon = formatLonEW(maxLonRaw);
        document.getElementById("visibleRange").innerHTML =
          `Visible range (EL > ${MIN_ELEVATION}°):<br>${minLon} to ${maxLon}`;
      } else {
        document.getElementById("visibleRange").innerHTML =
          `No satellites visible above horizon`;
      }
      copyBtn.disabled = false;
      pdfBtn.disabled = false;
      computeSatRangesAndRender();
      drawElGraph(lat, lon);
      buildLegendAndMap();
      updateSatelliteLists();
      updateSatelliteDropdown();
      calculateTrim(az, el);
    }
    async function getAndShowLocation() {
      if (!('geolocation' in navigator)) {
        alert("Geolocation not supported.");
        return;
      }
      const opts = { enableHighAccuracy: true, maximumAge: 0, timeout: 20000 };
      return new Promise(resolve => {
        navigator.geolocation.getCurrentPosition(pos => {
          const c = pos.coords;
          
          updateCoordinatesFromMapClick(c.latitude, c.longitude);

          updateAll();
          resolve();
        }, err => {
          alert('Location error: ' + err.message);
          resolve();
        }, opts);
      });
    }
    refreshBtn.addEventListener("click", () => getAndShowLocation());
    copyBtn.addEventListener("click", () => {
      const { lat, lon, satLon, heading } = getLatLon();
      const latText = formatNumber(Math.abs(lat)) + "°" + (lat >= 0 ? "N" : "S");
      const lonText = formatNumber(Math.abs(lon)) + "°" + (lon >= 0 ? "E" : "W");
      const satLonText = formatLonEW(satLon);
      let text = `Lat=${latText}\nLon=${lonText}\nSatLon=${satLonText}\nHeading=${heading}\n\n`;
      const visibleRangeEl = document.getElementById("visibleRange");
      if (visibleRangeEl && visibleRangeEl.textContent.trim() !== "") {
        text += visibleRangeEl.textContent + "\n\n";
      }
      const rows = Array.from(zonesBody.querySelectorAll("tr"));
      if (rows.length > 0) {
        text += "Blockage Zones:\n";
        rows.forEach((row, idx) => {
          const start = row.cells[0].querySelector("input").value;
          const stop = row.cells[1].querySelector("input").value;
          text += `  Zone ${idx + 1}: ${start}°–${stop}°\n`;
        });
      }
      const ranges = satRangesList.innerText.trim();
      if (ranges !== "") {
        text += "Blocking ranges:\n" + ranges + "\n";
      }
      navigator.clipboard.writeText(text).then(() => {
        copyBtn.textContent = "Copied!";
        setTimeout(() => copyBtn.textContent = "Copy", 1000);
      });
    });
  
  
pdfBtn.addEventListener("click", () => {
    const isMobile = window.innerWidth < 1024;
    
    pdfBtn.textContent = 'Generating...';
    pdfBtn.disabled = true;

    if (isMobile) {
      document.body.classList.add('pdf-export-mode');
      updateAll(); // Redraw canvases for the temporary desktop layout
    }

    const elementToCapture = document.querySelector('.main-container .card:first-child');
    
    const h2cOptions = {
        scale: 2,
        useCORS: true,
        letterRendering: true,
        ignoreElements: (element) => element.hasAttribute('data-html2canvas-ignore') || element.closest('[data-html2canvas-ignore]')
    };

    // Use a short timeout to ensure the DOM has fully updated after class change.
    setTimeout(() => {
        html2canvas(elementToCapture, h2cOptions).then(canvas => {
            const imgData = canvas.toDataURL('image/jpeg', 0.95);
            const { jsPDF } = window.jspdf;
            
            const pdf = new jsPDF({
                orientation: 'portrait',
                unit: 'in',
                format: 'a4'
            });

            const pageMargin = 0.5;
            const pdfPageWidth = pdf.internal.pageSize.getWidth();
            const pdfPageHeight = pdf.internal.pageSize.getHeight();
            const pdfContentWidth = pdfPageWidth - (pageMargin * 2);
            const pdfContentHeight = pdfPageHeight - (pageMargin * 2);

            const imgWidth = canvas.width;
            const imgHeight = canvas.height;
            const aspectRatio = imgHeight / imgWidth;

            let finalImgWidth = pdfContentWidth;
            let finalImgHeight = pdfContentWidth * aspectRatio;
            
            if (finalImgHeight > pdfContentHeight) {
                finalImgHeight = pdfContentHeight;
                finalImgWidth = pdfContentHeight / aspectRatio;
            }

            const posX = (pdfPageWidth - finalImgWidth) / 2;
            const posY = (pdfPageHeight - finalImgHeight) / 2;

            pdf.addImage(imgData, 'JPEG', posX, posY, finalImgWidth, finalImgHeight);
            
            const filename = 'MTN_Satellite_Report.pdf';
            pdf.save(filename);

        }).catch(err => {
            console.error("PDF generation failed:", err);
            alert("Sorry, there was an error creating the PDF. Please check the console for details.");
        }).finally(() => {
            if (isMobile) {
              document.body.classList.remove('pdf-export-mode');
              updateAll(); // Redraw back to the original mobile layout
            }
            pdfBtn.textContent = 'PDF';
            pdfBtn.disabled = false;
        });
    }, 100);
});
  
    // Apply normalization on input blur/change
    [latEl, lonEl, satLonEl].forEach(inp => {
      inp.addEventListener("blur", () => {
        normalizeInput(inp, 180); // 180 max is for degrees magnitude
        updateAll();
      });
      inp.addEventListener("input", updateAll);
      inp.addEventListener("focus", e => setTimeout(() => e.target.select(), 0));
    });
    [latDir, lonDir, satLonDir].forEach(sel => sel.addEventListener("change", () => {
        normalizeInput(lonEl.id === 'lon' ? lonEl : satLonEl, 180);
        updateAll();
    }));
    
    headingEl.addEventListener("blur", () => {
      normalizeInput(headingEl, 360);
      updateAll();
    });
    headingEl.addEventListener("input", updateAll);
    headingEl.addEventListener("focus", e => setTimeout(() => e.target.select(), 0));
    
    [azGreenEl, azCurrentEl, elGreenEl, elCurrentEl].forEach(inp => {
        inp.addEventListener("input", updateAll);
        inp.addEventListener("blur", () => {
            normalizeInput(inp); 
            updateAll();
        });
        inp.addEventListener("focus", e => setTimeout(() => e.target.select(), 0));
    });

    function updateCoordinatesFromMapClick(lat, lon) {
        latEl.value = formatNumber(Math.abs(lat));
        latDir.value = lat >= 0 ? "N" : "S";
        let rawLon = lon;
        let lonDirection = rawLon >= 0 ? "E" : "W";
        let absLon = Math.abs(rawLon);

        let normalizedLon = absLon;
        if (absLon > 180) {
            normalizedLon = 360 - absLon;
            lonDirection = (lonDirection === "E") ? "W" : "E";
        }
        
        if (normalizedLon === 360) normalizedLon = 0;
        
        lonEl.value = formatNumber(normalizedLon);
        lonDir.value = lonDirection;
    }

    function computeSatRangesForZone(startAZ, stopAZ, lat, lon, heading, step = 1) {
      const start = (startAZ + 360) % 360;
      const stop = (stopAZ + 360) % 360;
      const segments = [];
      let inside = false;
      let segStart = null;
      const nSteps = Math.round((360 / step));
      for (let i = 0; i <= nSteps; i++) {
        const satLon = -180 + i * step;
        const { az, el } = calcAzEl(lat, lon, satLon);
        if (el < 0) {
          if (inside) {
            const endEstimate = refineBoundary(segStart, satLon - step, lat, lon, heading, start, stop, step);
            segments.push([segStart, endEstimate]);
            inside = false;
            segStart = null;
          }
          continue;
        }
        const rel = ((az - heading) + 360) % 360;
        let inZone = false;
        if (start <= stop) {
          inZone = (rel >= start && rel <= stop);
        } else {
          inZone = (rel >= start || rel <= stop);
        }
        if (inZone && !inside) {
          const entry = refineBoundary(satLon - step, satLon, lat, lon, heading, start, stop, step, true);
          segStart = entry;
          inside = true;
        } else if (!inZone && inside) {
          const exit = refineBoundary(satLon - step, satLon, lat, lon, heading, start, stop, step);
          segments.push([segStart, exit]);
          inside = false;
          segStart = null;
        }
      }
      if (inside) {
        segments.push([segStart, 180]);
      }
      console.debug('computeSatRangesForZone', { startAZ, stopAZ, segments });
      return segments;
    }
    function refineBoundary(a, b, lat, lon, heading, start, stop, coarseStep, findEntry = false) {
      if (a < -180) a = -180;
      if (b > 180) b = 180;
      const subSteps = 10;
      let best = findEntry ? b : a;
      for (let k = 0; k <= subSteps; k++) {
        const t = k / subSteps;
        const satLon = a + (b - a) * t;
        const { az, el } = calcAzEl(lat, lon, satLon);
        if (el < 0) continue;
        const rel = ((az - heading) + 360) % 360;
        let inZone = false;
        if (start <= stop) inZone = (rel >= start && rel <= stop);
        else inZone = (rel >= start || rel <= stop);
        if (inZone) {
          if (findEntry) {
            best = Math.min(best, satLon);
          } else {
            best = Math.max(best, satLon);
          }
        }
      }
      return Math.round(best * 100) / 100;
    }
    function computeSatRangesAndRender() {
      const { lat, lon, heading } = getLatLon();
      const rows = Array.from(zonesBody.querySelectorAll('tr'));
      if (rows.length === 0) {
        satRangesList.innerHTML = "<i>(no Blockage Zones)</i>";
        return;
      }
      const sampleStep = 0.5;
      const outPieces = [];
      rows.forEach((row, idx) => {
        const start = parseFloat(row.cells[0].querySelector("input").value);
        const stop = parseFloat(row.cells[1].querySelector("input").value);
        if (isNaN(start) || isNaN(stop)) return;
        let ranges = computeSatRangesForZone(start, stop, lat, lon, heading, sampleStep);
        const west = [], east = [];
        ranges.forEach(([a, b]) => {
          let A = ((a + 540) % 360) - 180;
          let B = ((b + 540) % 360) - 180;
          if (A > B) {
            const tmp = A;
            A = B;
            B = tmp;
          }
          if (B <= 0) {
            const lo = Math.abs(B);
            const hi = Math.abs(A);
            west.push([lo, hi]);
          } else if (A >= 0) {
            east.push([A, B]);
          } else {
            west.push([Math.abs(A), 180]);
            east.push([0, B]);
          }
        });
        function mergeIntervals(list) {
          if (list.length <= 1) return list;
          list.sort((a, b) => a[0] - b[0]);
          const merged = [list[0].slice()];
          for (let i = 1; i < list.length; i++) {
            const [s, e] = list[i];
            const last = merged[merged.length - 1];
            if (s <= last[1] + 0.5) {
              last[1] = Math.max(last[1], e);
            } else merged.push([s, e]);
          }
          return merged;
        }
        const mergedWest = mergeIntervals(west);
        const mergedEast = mergeIntervals(east);
        const parts = [];
        mergedWest.forEach(([lo, hi]) => {
          if (hi < lo) {
            const t = lo;
            lo = hi;
            hi = t;
          }
          parts.push(`${formatNumber(lo)}°W to ${formatNumber(hi)}°W`);
        });
        mergedEast.forEach(([lo, hi]) => {
          if (hi < lo) {
            const t = lo;
            lo = hi;
            hi = t;
          }
          parts.push(`${formatNumber(lo)}°E to ${formatNumber(hi)}°E`);
        });
        
        const zoneColor = zoneColors[idx % zoneColors.length].replace("0.5", "1.0");

        if (parts.length === 0) {
          outPieces.push(`<div><span style="color:${zoneColor};">&#9679;</span> Zone ${idx + 1} No blockage for visible Satellites</div>`);
        } else {
          outPieces.push(`<div><span style="color:${zoneColor};">&#9679;</span> Zone ${idx + 1} Blockage range:  ${parts.join(', ')}</div>`);
        }
      });
    
    if (outPieces.length === 0) {
        satRangesList.innerHTML = "<i>(no Blockage Zones)</i>";
        satRangesList.classList.remove("two-col");
      } else {
        satRangesList.innerHTML = outPieces.join("");
        if (outPieces.length > 1) {
          satRangesList.classList.add("two-col");
        } else {
          satRangesList.classList.remove("two-col");
        }
      }
    }
    function setupKeyboardNavigation() {
      const focusable = Array.from(document.querySelectorAll("input, select"));
      focusable.forEach((el, idx) => {
        el.onkeydown = (e) => {
          let newIndex = null;
          if (e.key === "Enter" && el.tagName !== "SELECT") {
            e.preventDefault();
            newIndex = e.shiftKey ? idx - 1 : idx + 1;
          }
          if (el.tagName !== "SELECT") {
            if (e.key === "ArrowRight" || e.key === "ArrowDown") {
              e.preventDefault();
              newIndex = idx + 1;
            }
            if (e.key === "ArrowLeft" || e.key === "ArrowUp") {
              e.preventDefault();
              newIndex = idx - 1;
            }
          }
          if (newIndex !== null) {
            if (newIndex < 0) newIndex = focusable.length - 1;
            if (newIndex >= focusable.length) newIndex = 0;
            focusable[newIndex].focus();
          }
        };
      });
    }

    function handleElGraphClick(event) {
        const canvas = elGraphCanvas;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const mouseX = (event.clientX - rect.left) * scaleX;
        const mouseY = (event.clientY - rect.top) * scaleY;
        
        const clickRadius = 12; // A bit larger than the drawn radius of 8

        for (const point of elGraphSatPoints) {
            const distance = Math.sqrt(Math.pow(mouseX - point.x, 2) + Math.pow(mouseY - point.y, 2));
            if (distance <= clickRadius) {
                const newSatLon = point.lon;
                
                satLonEl.value = formatNumber(Math.abs(newSatLon));
                satLonDir.value = newSatLon < 0 ? 'W' : 'E';
                
                const userPoint = { lat: getLatLon().lat, lng: getLatLon().lon };
                Object.keys(allBeamsData).forEach(id => {
                    const beamData = allBeamsData[id];
                    beamData.isChecked = (beamData.longitude === newSatLon && checkFootprintVisibility(beamData, userPoint));
                });

                updateAll();
                break;
            }
        }
    }

    function handleElGraphMouseMove(event) {
        const canvas = elGraphCanvas;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const mouseX = (event.clientX - rect.left) * scaleX;
        const mouseY = (event.clientY - rect.top) * scaleY;
        
        const hoverRadius = 12;
        let onPoint = false;

        for (const point of elGraphSatPoints) {
            const distance = Math.sqrt(Math.pow(mouseX - point.x, 2) + Math.pow(mouseY - point.y, 2));
            if (distance <= hoverRadius) {
                onPoint = true;
                break;
            }
        }
        canvas.style.cursor = onPoint ? 'pointer' : 'default';
    }


    window.addEventListener('DOMContentLoaded', () => {
      setupKeyboardNavigation();
      updateAll();

      const { lat, lon, satLon } = getLatLon();
      if (!isNaN(lat) && !isNaN(lon) && !isNaN(satLon)) {
          const { az, el } = calcAzEl(lat, lon, satLon);
          azGreenEl.value = formatNumber(az);
          elGreenEl.value = formatNumber(el);
      }
      elGraphCanvas.addEventListener('click', handleElGraphClick);
      elGraphCanvas.addEventListener('mousemove', handleElGraphMouseMove);
    });
    window.addEventListener("error", function(event) {
      let msg = document.getElementById("errorBox");
      if (!msg) {
        msg = document.createElement("div");
        msg.id = "errorBox";
        msg.style.background = "#fee";
        msg.style.color = "red";
        msg.style.padding = "8px";
        msg.style.border = "1px solid red";
        msg.style.margin = "10px 0";
        msg.style.fontWeight = "bold";
        document.body.prepend(msg);
      }
      msg.textContent = "⚠️ Error: " + event.message + " (line " + event.lineno + ")";
    });
    window.addEventListener("resize", updateAll);

    const WORLD_MAX_BOUNDS = L.latLngBounds(
        L.latLng(-90, -180),
        L.latLng(90, 540)
    );

    let mymap = L.map('mapid', {
        bounceAtZoomLimits: false,
        maxBounds: WORLD_MAX_BOUNDS,
        maxBoundsViscosity: 1.0,
        worldCopyJump: true
    }).setView([0, 0], 2);

    let userMarkerGroup = L.layerGroup().addTo(mymap);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap contributors</a>',
        bounds: L.latLngBounds([[-90, -180], [90, 540]]),
        noWrap: false
    }).addTo(mymap);

    if (mymap && mymap.getContainer()) {
        mymap.panTo([0, 0]);
    }
    
    let userMarker = null;
    let legendControl;
    let allBeamsData = {};
    let layersMap = new Map();
    const satDropdown = document.getElementById('satDropdown');
    let colorMap = {};

    
    mymap.on('click', function(e) {
      const newLat = e.latlng.lat;
      const newLon = e.latlng.lng;
      updateCoordinatesFromMapClick(newLat, newLon);
      updateAll();
    });

    const fileInput = document.getElementById('file-input');
    fileInput.addEventListener('change', handleFileSelect, false);
    
    satDropdown.addEventListener('change', () => {
        const selectedLon = satDropdown.value;
        if (selectedLon) {
            satLonEl.value = formatNumber(Math.abs(selectedLon));
            satLonDir.value = parseFloat(selectedLon) < 0 ? 'W' : 'E';
        }
        updateAll();
    });
    
    function generateColors(num) {
        const colors = [];
        for (let i = 0; i < num; i++) {
            const hue = i * (360 / num);
            colors.push(`hsl(${hue}, 70%, 50%)`);
        }
        return colors;
    }

    function formatLongitude(longitude) {
        return `${Math.abs(longitude)}°${longitude >= 0 ? 'E' : 'W'}`;
    }

    function handleAntimeridianCrossing(points) {
      if (!points || points.length < 2) return points;
      let newPoints = [[points[0][0], points[0][1]]]; 
      for (let i = 1; i < points.length; i++) {
          const currentLat = points[i][0];
          const currentLon = points[i][1];
          const prevAdjLon = newPoints[i - 1][1]; 
          const prevRawLon = points[i - 1][1];
          let diff = currentLon - prevRawLon;
          if (diff > 180) diff -= 360;
          else if (diff < -180) diff += 360;
          let newLon = prevAdjLon + diff;
          newPoints.push([currentLat, newLon]);
      }
      return newPoints;
    }
    
    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const jsonContent = JSON.parse(e.target.result);
          processConstellationData(jsonContent);
        } catch (error) {
          alert('Error parsing JSON file: ' + error.message);
        }
      };
      reader.readAsText(file);
    }
    
    function processConstellationData(data) {
        if (!data.CONSTELLATION || !data.CONSTELLATION.SATELLITES) {
            alert('Invalid JSON structure.');
            return;
        }
        
        if (legendControl) mymap.removeControl(legendControl);
        mymap.eachLayer(layer => {
            if (layer.options.isContour) mymap.removeLayer(layer);
        });

        allBeamsData = {};
        layersMap = new Map();

        const filteredSatellites = data.CONSTELLATION.SATELLITES.filter(satellite => 
            satellite.satellite_id && !String(satellite.satellite_id).toLowerCase().startsWith('test')
        );
        
        filteredSatellites.forEach(satellite => {
            if (satellite.BEAM && satellite.CARRIER) {
                satellite.BEAM.forEach(beam => {
                    const carriers = satellite.CARRIER.filter(c => c.beam_id === beam.beam_id);
                    if (carriers.length > 0) {
                        const uniqueId = `${satellite.satellite_id}-${beam.beam_id}`;
                        allBeamsData[uniqueId] = {
                            satelliteId: satellite.satellite_id,
                            longitude: satellite.longitude,
                            formattedLongitude: formatLongitude(satellite.longitude),
                            beamId: beam.beam_id,
                            contours: beam.CONTOUR || [],
                            carriers: carriers,
                            layer: null,
                            isChecked: false
                        };
                    }
                });
            }
        });
        
        const sortedBeamIds = Object.keys(allBeamsData).sort((a, b) => {
            return allBeamsData[a].longitude - b.longitude;
        });

        colorMap = {};
        const colors = generateColors(sortedBeamIds.length);
        sortedBeamIds.forEach((id, index) => { colorMap[id] = colors[index]; });

        sortedBeamIds.forEach(id => {
            const beamData = allBeamsData[id];
            const beamColor = colorMap[id];
            const layers = [];
            
            beamData.contours.forEach(contour => {
                if (contour.type === 1 && contour.points) {
                    const validPoints = contour.points.filter(p => p && p.length === 2 && !isNaN(p[0]) && !isNaN(p[1]));
                    if (validPoints.length < 3) return;

                    const antimeridianFixedPoints = handleAntimeridianCrossing(validPoints);
                    const addPolygonLayer = (points, shift) => {
                        const shiftedPoints = points.map(p => [p[0], p[1] + shift]);
                        const layer = L.polygon(shiftedPoints, { color: beamColor, isContour: true });
                        L.DomEvent.disableClickPropagation(layer);
                        return layer;
                    };
                    layers.push(addPolygonLayer(antimeridianFixedPoints, 0));
                    layers.push(addPolygonLayer(antimeridianFixedPoints, -360));
                    layers.push(addPolygonLayer(antimeridianFixedPoints, 360));
                    
                } else if (contour.type === 0 && contour.center && contour.radius) {
                    const center = [contour.center[0], contour.center[1]];
                    const radius = contour.radius * 1000;
                    layers.push(L.circle(center, { color: beamColor, fillColor: beamColor, fillOpacity: 0.5, radius: radius, isContour: true }));
                    layers.push(L.circle([center[0], center[1] - 360], { color: beamColor, fillColor: beamColor, fillOpacity: 0.5, radius: radius, isContour: true }));
                    layers.push(L.circle([center[0], center[1] + 360], { color: beamColor, fillColor: beamColor, fillOpacity: 0.5, radius: radius, isContour: true }));
                }
            });
            const layerGroup = L.layerGroup(layers);
            allBeamsData[id].layer = layerGroup;
        });

        updateAll();
    }

    function showOnlyBeamOnMap(selectedBeamId) {
        Object.keys(allBeamsData).forEach(id => {
            const beamData = allBeamsData[id];
            beamData.isChecked = false; 
            const checkbox = document.getElementById(`beam-checkbox-${id}`);
            if (checkbox) checkbox.checked = false; 
            if (mymap.hasLayer(beamData.layer)) mymap.removeLayer(beamData.layer);
        });

        const beamData = allBeamsData[selectedBeamId];
        if (beamData) {
            beamData.isChecked = true;
            mymap.panTo([getLatLon().lat, beamData.longitude]); 
        }
    }
    
    function isPointInPolygon(point, polygon) {
        let x = point.lat, y = point.lng;
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            let xi = polygon[i][0], yi = polygon[i][1];
            let xj = polygon[j][0], yj = polygon[j][1];
            let intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }

    function checkFootprintVisibility(beamData, userPoint) {
        let isUserInFootprint = false;
        beamData.contours.forEach(contour => {
            if (isUserInFootprint) return;
            if (contour.type === 1 && contour.points) {
                const correctedPoints = handleAntimeridianCrossing(contour.points);
                const userLat = userPoint.lat;
                const userLon = userPoint.lng;
                let minLon = Infinity, maxLon = -Infinity;
                correctedPoints.forEach(p => { minLon = Math.min(minLon, p[1]); maxLon = Math.max(maxLon, p[1]); });
                
                const potentialUserLons = [userLon, userLon + 360, userLon - 360];
                for (const shiftedUserLon of potentialUserLons) {
                    if (shiftedUserLon >= minLon - 1 && shiftedUserLon <= maxLon + 1) {
                         if (isPointInPolygon({ lat: userLat, lng: shiftedUserLon }, correctedPoints)) {
                             isUserInFootprint = true;
                             break;
                         }
                    }
                }
            } else if (contour.type === 0 && contour.center && contour.radius) {
                const center = { lat: contour.center[0], lng: contour.center[1] };
                const userLat = userPoint.lat, userLon = userPoint.lng;
                const centerLons = [center.lng, center.lng + 360, center.lng - 360];
                const radiusM = contour.radius * 1000;
                for (const centerLon of centerLons) {
                    if (mymap.distance(L.latLng(userLat, userLon), L.latLng(center.lat, centerLon)) <= radiusM) {
                        isUserInFootprint = true;
                        break;
                    }
                }
            }
        });
        return isUserInFootprint;
    }

    function showBeamDetails(beamData) {
        if (!beamData) {
            beamDetailsEl.innerHTML = '';
            return;
        }
        const carriersInfo = beamData.carriers.map(carrier => `
- RF Center Freq: ${(parseFloat(carrier.center_freq) / 1000).toFixed(2)} KHz<br>
- Polarization: ${carrier.polarization}<br>
- Symbol Rate: ${carrier.symbol_rate}<br>
`).join('');
        
        beamDetailsEl.innerHTML = `
<b>Satellite ID:</b> ${beamData.satelliteId}<br>
<b>Longitude:</b> ${beamData.formattedLongitude}<br>
<b>Beam ID:</b> ${beamData.beamId}<br>
<hr style="margin: 8px 0; border-color: var(--border-color);">
${carriersInfo}
`;
    }

    function updateSatelliteDropdown() {
      const { lat, lon } = getLatLon();
      const userPoint = { lat: lat, lng: lon };
      satDropdown.innerHTML = '<option><option value="">Select a visible satellite</option></option>';
      const visibleBeams = Object.values(allBeamsData).filter(beamData => 
        checkFootprintVisibility(beamData, userPoint)
      ).sort((a, b) => a.longitude - b.longitude);
      const uniqueVisibleSatellites = new Map();
      visibleBeams.forEach(beamData => {
        const satelliteKey = `${beamData.satelliteId}-${beamData.longitude}`;
        if (!uniqueVisibleSatellites.has(satelliteKey)) {
          const polarizations = [...new Set(visibleBeams.filter(b => b.satelliteId === beamData.satelliteId).flatMap(b => b.carriers.map(c => c.polarization)))].join(', ');
          uniqueVisibleSatellites.set(satelliteKey, { id: beamData.satelliteId, longitude: beamData.longitude, polarization: polarizations });
        }
      });
      const sortedUniqueSatellites = Array.from(uniqueVisibleSatellites.values()).sort((a, b) => a.longitude - b.longitude);
      sortedUniqueSatellites.forEach(sat => {
        const option = document.createElement('option');
        option.value = sat.longitude;
        option.textContent = `${sat.id} (${formatLongitude(sat.longitude)}) - ${sat.polarization}`;
        satDropdown.appendChild(option);
      });
    }

    function buildLegendAndMap() {
        if (legendControl) {
            mymap.removeControl(legendControl);
            legendControl = null;
        }
        const mobileLegendContainer = document.getElementById('legend-container-mobile');
        if (mobileLegendContainer) {
          mobileLegendContainer.innerHTML = '';
        }

        const { lat, lon, satLon } = getLatLon();
        const userPoint = L.latLng(lat, lon);
        const currentZoom = mymap.getZoom(); 

        userMarkerGroup.clearLayers();
        if (!userMarker) userMarker = L.marker([lat, lon]);
        userMarker.setLatLng(userPoint);
        userMarkerGroup.addLayer(userMarker);
        userMarkerGroup.addLayer(L.marker(L.latLng(lat, lon + 360)));
        userMarkerGroup.addLayer(L.marker(L.latLng(lat, lon - 360)));
        
        mymap.setView([lat, lon], currentZoom); 

        const uniqueBeamIds = Object.keys(allBeamsData).sort((a, b) => allBeamsData[a].longitude - b.longitude);

        if (uniqueBeamIds.length === 0) {
            showBeamDetails(null);
            return;
        }

        const visibleBeamLongitudes = new Set();
        uniqueBeamIds.forEach(id => {
            if (checkFootprintVisibility(allBeamsData[id], { lat, lng: lon })) {
                visibleBeamLongitudes.add(allBeamsData[id].longitude);
            }
        });

        if (visibleBeamLongitudes.size > 0 && !visibleBeamLongitudes.has(satLon)) {
            uniqueBeamIds.forEach(id => {
                allBeamsData[id].isChecked = false;
            });
        } else {
            const anyBeamIsChecked = uniqueBeamIds.some(id => allBeamsData[id].isChecked);
            if (!anyBeamIsChecked && visibleBeamLongitudes.has(satLon)) {
                uniqueBeamIds.forEach(id => {
                    const beamData = allBeamsData[id];
                    if (checkFootprintVisibility(beamData, { lat, lng: lon }) && beamData.longitude === satLon) {
                        beamData.isChecked = true;
                    }
                });
            }
        }
        
        uniqueBeamIds.forEach(id => {
            const beamData = allBeamsData[id];
            if (beamData.layer) {
                if (beamData.isChecked && !mymap.hasLayer(beamData.layer)) {
                    mymap.addLayer(beamData.layer);
                } else if (!beamData.isChecked && mymap.hasLayer(beamData.layer)) {
                    mymap.removeLayer(beamData.layer);
                }
            }
        });

        const createLegendContent = (container) => {
            container.innerHTML = '<h4>Select Beams</h4>';

            const selectAllBtn = document.createElement('button');
            selectAllBtn.className = 'legend-button';
            selectAllBtn.textContent = 'Select All Visible';
            selectAllBtn.onclick = () => {
                uniqueBeamIds.forEach(id => {
                    const beamData = allBeamsData[id];
                    if (checkFootprintVisibility(beamData, userPoint)) {
                        const checkbox = document.getElementById(`beam-checkbox-${id}`);
                        if (checkbox && !checkbox.checked) {
                            checkbox.checked = true;
                            beamData.isChecked = true;
                            if (!mymap.hasLayer(beamData.layer)) mymap.addLayer(beamData.layer);
                        }
                    }
                });
            };
            container.appendChild(selectAllBtn);

            const deselectAllBtn = document.createElement('button');
            deselectAllBtn.className = 'legend-button';
            deselectAllBtn.textContent = 'Deselect All';
            deselectAllBtn.onclick = () => {
                uniqueBeamIds.forEach(id => {
                    const beamData = allBeamsData[id];
                    const checkbox = document.getElementById(`beam-checkbox-${id}`);
                    if (checkbox && checkbox.checked) {
                        checkbox.checked = false;
                        beamData.isChecked = false;
                        if (mymap.hasLayer(beamData.layer)) mymap.removeLayer(beamData.layer);
                    }
                });
                showBeamDetails(null);
            };
            container.appendChild(deselectAllBtn);
            
            uniqueBeamIds.forEach((id) => {
                const beamData = allBeamsData[id];
                const isVisible = checkFootprintVisibility(beamData, userPoint);

                if (isVisible) {
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `beam-checkbox-${id}`;
                    checkbox.checked = beamData.isChecked; 
                    checkbox.onchange = (e) => {
                        beamData.isChecked = e.target.checked;
                        if (e.target.checked) {
                            if (!mymap.hasLayer(beamData.layer)) mymap.addLayer(beamData.layer);
                        } else {
                            if (mymap.hasLayer(beamData.layer)) mymap.removeLayer(beamData.layer);
                        }
                    };
                    item.appendChild(checkbox);

                    const colorBox = document.createElement('i');
                    colorBox.style.background = colorMap[id];
                    item.appendChild(colorBox);

                    const polarizations = [...new Set(beamData.carriers.map(c => c.polarization))].join(', ');
                    const text = document.createElement('span');
                    text.innerHTML = `<b>${beamData.satelliteId}</b> (${formatLongitude(beamData.longitude)}) - Beam ${beamData.beamId} (${polarizations})`;
                    item.appendChild(text);

                    container.appendChild(item);
                }
            });
            L.DomEvent.disableScrollPropagation(container);
            L.DomEvent.disableClickPropagation(container);
        };

        if (window.innerWidth < 1024) {
            const legendDiv = document.createElement('div');
            legendDiv.className = 'info legend';
            createLegendContent(legendDiv);
            if (mobileLegendContainer) {
                mobileLegendContainer.appendChild(legendDiv);
            }
        } else {
            legendControl = L.control({position: 'bottomright'});
            legendControl.onAdd = function (map) {
                const div = L.DomUtil.create('div', 'info legend');
                createLegendContent(div);
                return div;
            };
            legendControl.addTo(mymap);
        }
    }
    
    function generateColors(num) {
        const colors = [];
        for (let i = 0; i < num; i++) {
            const hue = i * (360 / num);
            colors.push(`hsl(${hue}, 70%, 50%)`);
        }
        return colors;
    }
    
    function getBeamPolarizations(beamData) {
        return [...new Set(beamData.carriers.map(c => c.polarization))].join(', ');
    }
    
    function updateSatelliteLists() {
        const { lat, lon, heading, satLon } = getLatLon();
        const userPoint = { lat, lng: lon };
        
        visibleSatellitesList.innerHTML = '<h4>Visible and Unblocked Satellites</h4>';
        blockedSatellitesList.innerHTML = '<h4>Blocked Satellites</h4>';
        
        const visibleBeams = Object.values(allBeamsData)
            .filter(beamData => checkFootprintVisibility(beamData, userPoint))
            .sort((a, b) => a.longitude - b.longitude);

        visibleBeams.forEach(beamData => {
            const { az, el } = calcAzEl(lat, lon, beamData.longitude);
            const rel = ((az - heading) + 360) % 360;
            const blockZones = checkBlockingZones(rel, el);
            
            const li = document.createElement('div');
            li.className = 'sat-list-item';
            
            const polarizations = getBeamPolarizations(beamData);
            const uniqueBeamId = `${beamData.satelliteId}-${beamData.beamId}`;
            const beamColor = colorMap[uniqueBeamId];
            const colorCircle = `<span style="color:${beamColor}; margin-right: 5px;">&#9679;</span>`;
            
            let liContent = `${beamData.satelliteId} (${formatLongitude(beamData.longitude)}) - Beam ${beamData.beamId} (${polarizations})`;
            
            if (blockZones) {
                const zoneInfo = blockZones.map(zone => {
                    const color = zoneColors[zone.index - 1].replace("0.5", "1.0"); 
                    return `<span style="color:${color};">&#9679;</span> Zone #${zone.index}`;
                }).join(', ');
                liContent += ` (${zoneInfo})`;
            }

            li.innerHTML = colorCircle + liContent;

            li.onclick = () => {
                satLonEl.value = formatNumber(Math.abs(beamData.longitude));
                satLonDir.value = beamData.longitude < 0 ? 'W' : 'E';
                showOnlyBeamOnMap(uniqueBeamId); 
                updateAll();
                highlightListItem(li, 'visibleSatellites');
                highlightListItem(li, 'blockedSatellites');
                showBeamDetails(beamData);
            };
            li.dataset.beamId = uniqueBeamId;

            if (blockZones) {
                blockedSatellitesList.appendChild(li);
            } else {
                visibleSatellitesList.appendChild(li);
            }
        });
        
        // After lists are built, highlight the selected item
        const selectedBeamId = Object.keys(allBeamsData).find(id => allBeamsData[id].isChecked);
        if (selectedBeamId) {
            const itemToSelect = document.querySelector(`.sat-list-item[data-beam-id="${selectedBeamId}"]`);
            if (itemToSelect) {
                itemToSelect.classList.add('selected');
                showBeamDetails(allBeamsData[selectedBeamId]);
            } else {
                showBeamDetails(null);
            }
        } else {
            showBeamDetails(null);
        }

        if (visibleSatellitesList.children.length <= 1) {
          const p = document.createElement('p');
          p.textContent = 'No unblocked beams found.'; p.style.color = 'var(--text-muted)';
          visibleSatellitesList.appendChild(p);
        }
        if (blockedSatellitesList.children.length <= 1) {
          const p = document.createElement('p');
          p.textContent = 'No blocked beams found.'; p.style.color = 'var(--text-muted)';
          blockedSatellitesList.appendChild(p);
        }
    }
    
    function highlightListItem(item, listId) {
        document.querySelectorAll('.sat-list-item').forEach(child => child.classList.remove('selected'));
        if (item) item.classList.add('selected');
    }

  </script>
</body>
</html>
